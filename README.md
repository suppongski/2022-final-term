# 모의 담금질 기법을 통한 회귀식 추정  
*인천대학교 정보통신공학과 201901687 양수진*
# 목차
    1. 모의 담금질 기법이란?
    2. 내가 선정한 데이터셋
    3. 작성한 코드의 동작방식
    4. 함수 및 매개변수 설명
    5. 
    6. 
    7. 이웃해 왜 이렇게 설정했는지?
    8. 모수값 추정(적절한지 검증)
    9. 최적화 과정에서 에러가 감소하는 경향 표현

1. **모의 담금질 기법이란?**
* 온도를 낮춰가며 최적해에 가까워지고 임계온도에 다다랐을때 전역 최적해에 가장 근사한 값을 도출하는 확률적 메타 알고리즘이다.

---
2. **내가 선정한 데이터셋**
* 현실에 실존하는 현상에 대한 실제값들 중 **2021년 6월 주택용 1~24시 전력소비계수**를 선정하였다.  
*전력소비자의 시간별 소비량 데이터를 바탕으로 가공된 상대계수로, 일간 평균을 기준(=1,000)으로 하여 시간별 사용량을 상대적으로 산출*
![image](https://user-images.githubusercontent.com/101388182/173496133-c56b9605-71f6-4bf3-98c1-54033914256a.png)
![image](https://user-images.githubusercontent.com/101388182/173863459-69235bc4-14dd-48a7-bd66-7c0fddc3d771.png)

출처: https://kosis.kr/statHtml/statHtml.do?orgId=310&tblId=DT_3664N_1&vw_cd=MT_ZTITLE&list_id=U_12&seqNo=&lang_mode=ko&language=kor&obj_var_id=&itm_id=&conn_path=MT_ZTITLE


---
3. **작성한 코드의 동작방식**
    1. 원하는 반복실행횟수를 생각하여 초기온도와 매 회차마다 감소할 온도감률, 도달시 반복실행을 종료할 임계온도를 설정한다
    2. 랜덤으로 y=ax+b 의 a와b를 설정하고 실제 데이터셋과의 오차값을 절대값으로 합하는 평가함수를 통해 평가값을 매긴다
    3. 평가값에 따라 더 최적인 a,b값으로 현재값을 수정하는 확률을 산출하고 랜덤값을 이용하여 확률에 따라 이행
    4. 반복실행이 종료되었을때 a,b값을 출력

---
4. **함수 및 매개변수 설명**
>함수
* ***func*** : 예측함수인 y=ax+b 의 x값에 따른 y값 리턴
* ***scoring*** : 오차값들의 절대값을 모두 더한 평가점수를 리턴
* ***simulated_annealing*** : 모의담금질 알고리즘 실행함수  

>매개변수
* ***elec_use*** : 시간별 전력소비계수
* ***a, b*** : 예측함수인 y=ax+b의 a와b
* ***tem*** : 초기온도
* ***dec*** : 매 반복실행마다 일정비율로 온도를 감소시키는 온도감률
* ***k*** : 볼츠만상수(*기체 1몰과 관계 있는 보편 기체 상수를 아보가드로수로 나눈 값으로 열 운동의 에너지와 온도가 관계를 맺게 하는 역할을 하며 1.380×10－23J/K이다. 코드에서는 간단하게 10으로 정의했다.*)
* ***lim*** : 도달하면 반복실행을 종료할 임계온도
* ***score*** : 평가함수를 통해 산출된 평가값
* ***now_s, next_s*** : 현재 예측함수의 평가값, 다음 실행회차의 예측함수 평가값
* ***a_sub, b_sub*** : a와b값을 임시저장할 변수


---
5. **Edmonds-Karp 알고리즘이란?**
* 최대유량 알고리즘을 해결할때 그래프의 경로를 찾는과정에서 너비우선탐색 *(BFS)* 을 활용하는 알고리즘이다.
* 너비우선탐색 그래프  
![bfs](https://user-images.githubusercontent.com/101388182/165445227-0f54787a-cead-4c7f-9c01-96d5644d9add.png)

---
6. **Edmonds-Karp 알고리즘 실행과정**  
Ford-Fulkerson 알고리즘과 경로탐색시 탐색방법에만 차이가 있고 나머지는 같다.
    1. 그래프에 존재하는 모든 엣지의 유량을 0 으로 초기화하고, 반대방향 엣지의 유량도 0 으로 초기화한다.
    2. 시작점에서 도착점으로 갈 수 있는 경로중 잔여 용량이 남은 경로를 **BFS** 로 탐색한다.
    3. 해당 경로에 존재하는 엣지들의 잔여용량 중 가장 작은 값을 유량으로 흘려보낸다.
    4. 해당 유량에 음수값을 취해, 반대방향 엣지에도 흘려보내 유량상쇄를 한다.
    5. 더 이상 잔여용량이 남은 경로가 존재하지 않을때까지 반복한다.
    6. 탐색했던 각 경로들의 최소유량을 합하면 최종적으로 구하고자 하는 최대유량을 알수있다.

---
7. **Edmonds-Karp 알고리즘 코드 실행결과**
* 최대유량 그래프 예시는 위의 Ford-Fulkerson 알고리즘의 예시와 같다.
* BFS 활용부분  
<img width="836" alt="애드몬드 활용부분" src="https://user-images.githubusercontent.com/101388182/165456030-75267f3f-6acd-4e11-928f-cd0cdea9cfda.PNG">

* 코드 실행결과창  
<img width="552" alt="애드몬드 실행결과창" src="https://user-images.githubusercontent.com/101388182/165446024-87b67e07-eeff-4cd8-bc8e-f8a3fcf7664a.PNG">

---
8. **각  코드의 성능분석**
* Ford-Fulkerson의 시간복잡도  
E = 엣지, V = 정점, F = 최대유량 일때 ***O(V + E) F)***
* Edmonds-Karp의 시간복잡도  
E = 엣지, V = 정점 일때 ***O(VE^2)***  

>이렇게 두 알고리즘은 시간복잡도에서 차이가 나므로 상황에 맞는 알고리즘을 활용해야 한다.  
>잘 알려진 예시로 최대유량 문제의 극단적인 상황이 있다.  
<img width="480" alt="극단적 예시" src="https://user-images.githubusercontent.com/101388182/165457666-14baba08-2ee0-4764-a22c-961b6d764bd4.PNG">

이런 그래프가 있고 Ford-Fulkerson 알고리즘으로 구현했다고 하자.  
    1. A→B→C→D 1의 유량 보냄  
    2. A→C→B→D 반대방향 엣지를 이용해 1의 유량 보냄  
    3. A→B→C→D 1의 유량 보냄  
    4. A→C→B→D 반대방향 엣지를 이용해 1의 유량 보냄  
    5. 1~4번 과정 반복  
최악의 경우 유량의 최댓값만큼 반복하게 된다.    

이번엔 Edmonds-Karp 알고리즘으로 구현했다고 하면  
    1. A→B→D 1000의 유량 보냄  
    2. A→C→D 1000의 유량 보냄  
이렇게 2번의 탐색으로 최대유량을 찾아낼 수 있다.  

* 결론  
유량의 값이 작고, 엣지가 많으면 Ford-Fulkerson이 더 빠를 수 있고  
엣지가 적고, 유량의 값이 크면 Edmonds-Karp가 더 빠를 수 있다.

---
9. 소감  
네트워크에 있어서 기본적인 Network Flow에 대해 완벽히 이해할수 있었고 무엇보다 C언어에 가장 자신이 있어서 C로 코딩하게 되었는데, 코딩중에 막히는 부분을 찾다가 덤으로 C++에서의 큐 관련 함수들을 배울 수 있어서 너무 보람찼다.
